import logging
import random
import asyncio
from telethon import TelegramClient, events, Button
from telethon.tl.functions.messages import SendVoteRequest, SendReactionRequest
try:
    from telethon.tl.types import ReactionEmoji
except ImportError:
    # Fallback for older Telethon versions
    from telethon.tl import types
    ReactionEmoji = getattr(types, 'ReactionEmoji', None)
from src.Config import CHANNEL_ID, REPORT_CHECK_BOT
from src.Validation import InputValidator
from src.smart_sender import SmartBulkSender

logger = logging.getLogger(__name__)

# Concurrency limit for bulk operations to avoid rate limiting
MAX_CONCURRENT_OPERATIONS = 3

class Actions:
    def __init__(self, tbot):
        self.tbot = tbot
        self.operation_semaphore = asyncio.Semaphore(MAX_CONCURRENT_OPERATIONS)
    
    async def get_available_accounts(self, num_accounts):
        """
        Get available accounts from active_clients.
        Tries to use accounts even if is_user_authorized() returns False,
        as many accounts work despite this.
        
        Returns:
            tuple: (available_accounts list, unavailable_sessions list)
        """
        available_accounts = []
        unavailable_sessions = []
        
        async with self.tbot.active_clients_lock:
            for session_name, client in list(self.tbot.active_clients.items())[:num_accounts]:
                try:
                    # Check if client is connected
                    if not client.is_connected():
                        try:
                            await client.connect()
                        except Exception as conn_error:
                            logger.warning(f"Could not connect {session_name}: {conn_error}")
                            unavailable_sessions.append(session_name)
                            continue

                    # Try to use the client - don't rely solely on is_user_authorized()
                    # Many clients work even if is_user_authorized() returns False
                    try:
                        # Try a simple operation to verify it works
                        await client.get_me()
                        available_accounts.append((session_name, client))
                        logger.info(f"Client {session_name} is available for use")
                    except Exception as auth_error:
                        error_msg = str(auth_error).lower()
                        # Only mark as unavailable if it's a real auth error
                        if 'session revoked' in error_msg or 'auth' in error_msg or 'invalid' in error_msg:
                            unavailable_sessions.append(session_name)
                            logger.warning(f"Client {session_name} has real auth issues: {auth_error}")
                        else:
                            # Temporary error - try to use it anyway
                            available_accounts.append((session_name, client))
                            logger.warning(f"Client {session_name} has temporary issue but will try to use: {auth_error}")
                except Exception as e:
                    logger.error(f"Error validating client {session_name}: {e}")
                    # Don't mark as unavailable for general errors - try to use it
                    try:
                        available_accounts.append((session_name, client))
                    except:
                        unavailable_sessions.append(session_name)
        
        return available_accounts, unavailable_sessions
    
    async def check_report_status(self, phone_number, account):
        """
        Check if a phone number is reported by sending a message to the report check bot.
        
        Args:
            phone_number: Phone number to check (e.g., +1234567890)
            account: TelegramClient instance to use for sending the check message
            
        Returns:
            bool: True if reported, False if not reported, None if check failed
        """
        if not REPORT_CHECK_BOT:
            logger.warning("REPORT_CHECK_BOT not configured. Skipping report check.")
            return None
        
        try:
            # Ensure account is connected
            if not account.is_connected():
                await account.connect()
            
            # Send phone number to report check bot
            check_message = phone_number
            sent_message = await account.send_message(REPORT_CHECK_BOT, check_message)
            logger.info(f"Sent check message to {REPORT_CHECK_BOT} for {phone_number}")
            
            # Wait a bit for the bot to respond (increase wait time)
            await asyncio.sleep(3)
            
            # Get messages from the report check bot (check last 5 messages to find the response)
            response_text = ""
            async for message in account.iter_messages(REPORT_CHECK_BOT, limit=5):
                # Check if this message is a reply to our sent message or is after our message
                if message.date > sent_message.date or (message.reply_to and message.reply_to.reply_to_msg_id == sent_message.id):
                    response_text = message.text if message.text else ""
                    logger.info(f"Found response from report bot: {response_text[:200]}")
                    break
            
            if not response_text:
                logger.warning(f"No response received from report bot for {phone_number}")
                return None
            
            response_lower = response_text.lower()
            
            # Check for report indicators in the response
            # Common indicators: "report", "reported", "banned", "restricted", "yes", "true", "1"
            report_indicators = ['report', 'reported', 'banned', 'restricted', 'yes', 'true', '1', 'âœ…', 'ğŸŸ¢', 'has report', 'is report']
            not_report_indicators = ['not report', 'not reported', 'no report', 'no', 'false', '0', 'âŒ', 'ğŸ”´', 'clean', 'safe', 'not banned', 'not restricted']
            
            # Check if response indicates report
            has_report_indicator = any(indicator in response_lower for indicator in report_indicators)
            has_not_report_indicator = any(indicator in response_lower for indicator in not_report_indicators)
            
            if has_report_indicator and not has_not_report_indicator:
                logger.info(f"Phone {phone_number} is REPORTED according to check bot")
                return True
            
            # Check if response indicates not reported
            if has_not_report_indicator:
                logger.info(f"Phone {phone_number} is NOT reported according to check bot")
                return False
            
            # If we can't determine, return None
            logger.warning(f"Could not determine report status for {phone_number} from response: {response_text[:100]}")
            return None
                
        except Exception as e:
            logger.error(f"Error checking report status for {phone_number}: {e}", exc_info=True)
            return None

    async def parse_telegram_link(self, link: str, account=None):
        """
        Parse a Telegram link to extract chat_id/entity and message_id.
        Resolves username to entity if account is provided.
        
        Args:
            link: Telegram message link (e.g., https://t.me/c/123456/789 or https://t.me/username/123)
            account: Optional TelegramClient instance to resolve usernames
            
        Returns:
            Tuple of (chat_id/entity, message_id) or (None, None) if parsing fails
        """
        try:
            # Remove protocol if present
            clean_link = link.replace('https://', '').replace('http://', '').strip()
            
            # Handle t.me/c/123456/789 format (private channels/groups)
            if '/c/' in clean_link:
                parts = clean_link.split('/c/')
                if len(parts) == 2:
                    chat_and_msg = parts[1].split('/')
                    if len(chat_and_msg) >= 2:
                        try:
                            chat_id = int('-100' + chat_and_msg[0])
                            message_id = int(chat_and_msg[1])
                            return chat_id, message_id
                        except ValueError:
                            logger.error(f"Invalid chat_id or message_id in link: {link}")
                            return None, None
            
            # Handle t.me/username/123 format (public channels/groups)
            if 't.me/' in clean_link:
                parts = clean_link.split('t.me/')
                if len(parts) == 2:
                    rest = parts[1].split('/')
                    if len(rest) >= 2:
                        chat_username = rest[0]
                        try:
                            message_id = int(rest[1])
                            # If account is provided, resolve username to entity
                            if account:
                                try:
                                    entity = await account.get_entity(chat_username)
                                    return entity, message_id
                                except Exception as e:
                                    logger.error(f"Error resolving username {chat_username}: {e}")
                                    return None, None
                            else:
                                return chat_username, message_id
                        except ValueError:
                            logger.error(f"Invalid message_id in link: {link}")
                            return None, None
            
            logger.error(f"Unable to parse link format: {link}")
            return None, None
            
        except Exception as e:
            logger.error(f"Error parsing Telegram link {link}: {e}", exc_info=True)
            return None, None

    async def prompt_group_action(self, event, action_name):
        """
        Prompt the user to enter the number of accounts to be used for the group action.
        """
        async with self.tbot.active_clients_lock:
            total_accounts = len(self.tbot.active_clients)
        
        message = f"There are {total_accounts} accounts available. Please choose how many accounts (from 1 to {total_accounts}) will perform the {action_name} action."
        buttons = [Button.inline(str(i), f"{action_name}_{i}") for i in range(1, total_accounts + 1)]
        await event.respond(message, buttons=buttons)

    async def prompt_individual_action(self, event, action_name):
        """
        Show a list of account names as clickable buttons and prompt the user to select which account should perform the action.
        """
        async with self.tbot.active_clients_lock:
            sessions = list(self.tbot.active_clients.keys())
        
        buttons = [Button.inline(session, f"{action_name}_{session}") for session in sessions]
        await event.respond("Please select an account to perform the action:", buttons=buttons)

    async def handle_group_action(self, event, action_name, num_accounts):
        """
        Handle the group action by calling the respective function for all selected accounts.
        Uses semaphore to limit concurrent operations and avoid rate limiting.
        """
        # Get available accounts using helper function
        available_accounts, unavailable_sessions = await self.get_available_accounts(num_accounts)
        
        # Don't show annoying message - just use available accounts silently
        if unavailable_sessions:
            logger.info(f"{len(unavailable_sessions)} accounts temporarily unavailable, using {len(available_accounts)} available accounts")

        # If no available accounts, stop
        if not available_accounts:
            await event.respond("âŒ No accounts are currently available for this operation. Please check account status or try again later.")
            return

        # Use available_accounts instead of valid_accounts
        valid_accounts = available_accounts

        # If no valid accounts, stop
        if not valid_accounts:
            await event.respond("âŒ Ù‡ÛŒÚ† Ø­Ø³Ø§Ø¨ Ù…Ø¹ØªØ¨Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§Øª ÛŒØ§ÙØª Ù†Ø´Ø¯.")
            return

        async def execute_action(session_name, account):
            """Execute action with concurrency limit"""
            async with self.operation_semaphore:
                try:
                    # Standard bulk operations
                    await getattr(self, action_name)(account, event)
                    # Add delay between operations to avoid rate limiting
                    await asyncio.sleep(random.uniform(1, 3))
                except Exception as e:
                    error_msg = str(e)
                    logger.error(f"Error executing {action_name} for account {session_name}: {error_msg}")

                    # If session is revoked, remove it from active clients
                    if "SessionRevokedError" in error_msg or "not logged in" in error_msg.lower():
                        async with self.tbot.active_clients_lock:
                            if session_name in self.tbot.active_clients:
                                logger.warning(f"Removing revoked session: {session_name}")
                                del self.tbot.active_clients[session_name]

        # Execute all actions concurrently with semaphore limiting
        # Use only valid accounts
        accounts_to_use = valid_accounts[:num_accounts]
        tasks = [execute_action(session_name, account) for session_name, account in accounts_to_use]
        await asyncio.gather(*tasks, return_exceptions=True)

    async def handle_individual_action(self, event, action_name, session):
        """
        Handle the individual action by calling the respective function for the selected account.
        """
        async with self.tbot.active_clients_lock:
            account = self.tbot.active_clients.get(session)
        
        if account:
            await getattr(self, action_name)(account, event)
        else:
            await event.respond(f"Account {session} not found.")

    async def reaction(self, account, event):
        """
        Perform the reaction action.
        """
        # Step 1: Ask for the link to the message
        await event.respond("Please provide the link to the message where the reaction will be applied.")
        self.tbot._conversations[event.chat_id] = 'reaction_link_handler'

    async def reaction_link_handler(self, event):
        """
        Handle the link input for the reaction action.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nPlease try again.")
                return
            
            await event.respond("Please select a reaction:", buttons=[
                Button.inline("ğŸ‘", b'reaction_thumbsup'),
                Button.inline("â¤ï¸", b'reaction_heart'),
                Button.inline("ğŸ˜‚", b'reaction_laugh'),
                Button.inline("ğŸ˜®", b'reaction_wow'),
                Button.inline("ğŸ˜¢", b'reaction_sad'),
                Button.inline("ğŸ˜¡", b'reaction_angry')
            ])
            self.tbot._conversations[event.chat_id] = 'reaction_select_handler'
            self.tbot.handlers['reaction_link'] = link
        except Exception as e:
            logger.error(f"Error in reaction_link_handler: {e}")
            await event.respond("Error processing link. Please try again.")
            self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('reaction_link', None)

    async def reaction_select_handler(self, event):
        """
        Handle the reaction selection.
        """
        # This handler should be added to callback handler, not message handler
        # It's triggered by inline button clicks
        reaction_map = {
            'reaction_thumbsup': 'ğŸ‘',
            'reaction_heart': 'â¤ï¸',
            'reaction_laugh': 'ğŸ˜‚',
            'reaction_wow': 'ğŸ˜®',
            'reaction_sad': 'ğŸ˜¢',
            'reaction_angry': 'ğŸ˜¡'
        }
        
        data = event.data.decode() if hasattr(event, 'data') else event.message.text.strip()
        reaction = reaction_map.get(data, data)
        
        async with self.tbot.active_clients_lock:
            total_accounts = len(self.tbot.active_clients)
        
        await event.respond(f"Please specify the number of reactions (from 1 to {total_accounts}):")
        self.tbot._conversations[event.chat_id] = 'reaction_count_handler'
        self.tbot.handlers['reaction'] = reaction

    async def reaction_count_handler(self, event):
        """
        Handle the number of reactions input.
        """
        try:
            count = int(event.message.text.strip())
            
            # Get available accounts using helper function
            async with self.tbot.active_clients_lock:
                total_clients = len(self.tbot.active_clients)
                if count < 1 or count > total_clients:
                    raise ValueError(f"Invalid number of reactions. Must be between 1 and {total_clients}.")
            
            available_accounts, unavailable_sessions = await self.get_available_accounts(count)
            
            # Don't show annoying message - just use available accounts silently
            if unavailable_sessions:
                logger.info(f"{len(unavailable_sessions)} accounts temporarily unavailable, using {len(available_accounts)} available accounts")

            # If no available accounts, stop
            if not available_accounts:
                await event.respond("âŒ No accounts are currently available for sending reactions. Please check account status or try again later.")
                # Cleanup
                self.tbot.handlers.pop('reaction_link', None)
                self.tbot.handlers.pop('reaction', None)
                async with self.tbot._conversations_lock:
                    self.tbot._conversations.pop(event.chat_id, None)
                return

            # Use available_accounts instead of valid_accounts
            valid_accounts = available_accounts

            link = self.tbot.handlers['reaction_link']
            reaction = self.tbot.handlers['reaction']

            # Use semaphore to limit concurrent reactions
            async def apply_reaction_with_limit(session_name, account):
                async with self.operation_semaphore:
                    try:
                        await self.apply_reaction(account, link, reaction)
                        await asyncio.sleep(random.uniform(2, 5))
                    except Exception as e:
                        error_msg = str(e)
                        logger.error(f"Error applying reaction with account {session_name}: {error_msg}")

                        # If session is revoked, remove it from active clients
                        if "SessionRevokedError" in error_msg or "not logged in" in error_msg.lower():
                            async with self.tbot.active_clients_lock:
                                if session_name in self.tbot.active_clients:
                                    logger.warning(f"Removing revoked session: {session_name}")
                                    del self.tbot.active_clients[session_name]

            # Execute all reactions with concurrency control
            # Use only valid accounts
            accounts_to_use = valid_accounts[:count]
            tasks = [apply_reaction_with_limit(session_name, account) for session_name, account in accounts_to_use]
            await asyncio.gather(*tasks, return_exceptions=True)
            
            await event.respond(f"Applied {reaction} reaction using {count} accounts.")
            
            # Cleanup
            self.tbot.handlers.pop('reaction_link', None)
            self.tbot.handlers.pop('reaction', None)
            self.tbot._conversations.pop(event.chat_id, None)
            
        except ValueError as e:
            await event.respond(f"Error: {e}. Please enter a valid number of reactions.")
            # Don't reset conversation state - let it stay to retry

    async def apply_reaction(self, account, link, reaction):
        """
        Apply the selected reaction using the given account.
        
        Args:
            account: TelegramClient instance
            link: Telegram message link
            reaction: Reaction emoji string
        """
        try:
            # Parse the link to get chat_id/entity and message_id
            chat_entity, message_id = await self.parse_telegram_link(link, account)
            
            if chat_entity is None or message_id is None:
                raise ValueError(f"Failed to parse link: {link}")
            
            # If chat_entity is a string (username), resolve it
            if isinstance(chat_entity, str):
                chat_entity = await account.get_entity(chat_entity)
            
            # Create reaction emoji object
            # Try different methods based on Telethon version
            if ReactionEmoji:
                reaction_emoji = ReactionEmoji(emoticon=reaction)
                reaction_obj = [reaction_emoji]
            else:
                # Fallback: use string directly (for older Telethon versions)
                reaction_obj = [reaction]
            
            # Send reaction using SendReactionRequest
            await account(SendReactionRequest(
                peer=chat_entity,
                msg_id=message_id,
                reaction=reaction_obj
            ))
            
            logger.info(f"Applied {reaction} reaction to message {message_id} using account {account.session.filename if hasattr(account, 'session') and hasattr(account.session, 'filename') else 'Unknown'}")
        except Exception as e:
            logger.error(f"Error applying reaction: {e}", exc_info=True)
            raise  # Re-raise to allow caller to handle

    async def poll(self, account, event):
        """
        Perform the poll action - vote on a poll.
        """
        await event.respond("Please provide the link to the poll:")
        self.tbot._conversations[event.chat_id] = 'poll_link_handler'
        self.tbot.handlers['poll_account'] = account

    async def poll_link_handler(self, event):
        """
        Handle the poll link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nPlease try again.")
                return
            
            self.tbot.handlers['poll_link'] = link
            await event.respond("Please enter the option number you want to vote for (e.g., 1, 2, 3):")
            self.tbot._conversations[event.chat_id] = 'poll_option_handler'
        except Exception as e:
            logger.error(f"Error in poll_link_handler: {e}")
            await event.respond("Error processing link. Please try again.")
            self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('poll_account', None)
            self.tbot.handlers.pop('poll_link', None)

    async def poll_option_handler(self, event):
        """
        Handle the poll option selection.
        """
        try:
            # Validate poll option
            is_valid, error_msg, option_num = InputValidator.validate_poll_option(event.message.text.strip())
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nPlease try again.")
                return
            
            option = option_num - 1  # Convert to 0-based index
            account = self.tbot.handlers.get('poll_account')
            link = self.tbot.handlers.get('poll_link')
            
            # Parse the link to get chat and message IDs
            parts = link.split('/')
            if 't.me/c/' in link:
                chat_id = int('-100' + parts[-2])
                message_id = int(parts[-1])
            else:
                chat_username = parts[-2]
                message_id = int(parts[-1])
                chat_id = chat_username
            
            # Get the poll message
            message = await account.get_messages(chat_id, ids=message_id)
            if message.poll:
                await account(SendVoteRequest(
                    peer=chat_id,
                    msg_id=message_id,
                    options=[bytes([option])]
                ))
                await event.respond(f"Successfully voted option {option + 1} using account {account.session.filename}")
            else:
                await event.respond("The provided link does not point to a poll.")
            
            # Cleanup
            self.tbot.handlers.pop('poll_account', None)
            self.tbot.handlers.pop('poll_link', None)
            self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error voting on poll: {e}")
            await event.respond(f"Error voting on poll: {str(e)}")
            self.tbot._conversations.pop(event.chat_id, None)

    async def join(self, account, event):
        """
        Perform the join action - join a group or channel.
        """
        await event.respond("Please provide the group/channel link or username to join:")
        self.tbot._conversations[event.chat_id] = 'join_link_handler'
        self.tbot.handlers['join_account'] = account

    async def join_link_handler(self, event):
        """
        Handle the join link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}")
                return
            
            account = self.tbot.handlers.get('join_account')
            
            # Join the group/channel
            await account.join_chat(link)
            await event.respond(f"Successfully joined {link} using account {account.session.filename}")
            
            # Cleanup
            self.tbot.handlers.pop('join_account', None)
            self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error joining group/channel: {e}")
            await event.respond(f"Error joining group/channel: {str(e)}")
            self.tbot._conversations.pop(event.chat_id, None)

    async def left(self, account, event):
        """
        Perform the left action - leave a group or channel.
        """
        await event.respond("Please provide the group/channel link or username to leave:")
        self.tbot._conversations[event.chat_id] = 'left_link_handler'
        self.tbot.handlers['left_account'] = account

    async def left_link_handler(self, event):
        """
        Handle the leave link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}")
                return
            
            account = self.tbot.handlers.get('left_account')
            
            # Leave the group/channel
            entity = await account.get_entity(link)
            await account.leave_chat(entity)
            await event.respond(f"Successfully left {link} using account {account.session.filename}")
            
            # Cleanup
            self.tbot.handlers.pop('left_account', None)
            self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error leaving group/channel: {e}")
            await event.respond(f"Error leaving group/channel: {str(e)}")
            self.tbot._conversations.pop(event.chat_id, None)

    async def block(self, account, event):
        """
        Perform the block action - block a user.
        """
        await event.respond("Please provide the user ID or username to block:")
        self.tbot._conversations[event.chat_id] = 'block_user_handler'
        self.tbot.handlers['block_account'] = account

    async def block_user_handler(self, event):
        """
        Handle the block user input.
        """
        try:
            user_input = event.message.text.strip()
            account = self.tbot.handlers.get('block_account')
            
            # Block the user
            from telethon.tl.functions.contacts import BlockRequest
            entity = await account.get_entity(user_input)
            await account(BlockRequest(entity))
            await event.respond(f"Successfully blocked user {user_input} using account {account.session.filename}")
            
            # Cleanup
            self.tbot.handlers.pop('block_account', None)
            self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error blocking user: {e}")
            await event.respond(f"Error blocking user: {str(e)}")
            self.tbot._conversations.pop(event.chat_id, None)


    async def comment(self, account, event):
        """
        Perform the comment action - comment on a post/message.
        """
        await event.respond("Please provide the link to the post/message:")
        self.tbot._conversations[event.chat_id] = 'comment_link_handler'
        self.tbot.handlers['comment_account'] = account

    async def comment_link_handler(self, event):
        """
        Handle the comment link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nPlease try again.")
                return
            
            self.tbot.handlers['comment_link'] = link
            await event.respond("Please enter your comment:")
            self.tbot._conversations[event.chat_id] = 'comment_text_handler'
        except Exception as e:
            logger.error(f"Error in comment_link_handler: {e}")
            await event.respond("Error processing link. Please try again.")
            self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('comment_account', None)
            self.tbot.handlers.pop('comment_link', None)

    async def comment_text_handler(self, event):
        """
        Handle the comment text input.
        """
        try:
            comment_text = event.message.text.strip()
            
            # Validate comment text
            is_valid, error_msg = InputValidator.validate_message_text(comment_text)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nPlease try again.")
                return
            
            account = self.tbot.handlers.get('comment_account')
            link = self.tbot.handlers.get('comment_link')
            
            # Parse the link to get chat and message IDs
            parts = link.split('/')
            if 't.me/c/' in link:
                chat_id = int('-100' + parts[-2])
                message_id = int(parts[-1])
            else:
                chat_username = parts[-2]
                message_id = int(parts[-1])
                chat_id = chat_username
            
            # Send the comment
            await account.send_message(chat_id, comment_text, reply_to=message_id)
            await event.respond(f"Successfully posted comment using account {account.session.filename}")
            
            # Cleanup
            self.tbot.handlers.pop('comment_account', None)
            self.tbot.handlers.pop('comment_link', None)
            self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error posting comment: {e}")
            await event.respond(f"Error posting comment: {str(e)}")
            self.tbot._conversations.pop(event.chat_id, None)

    async def join_link_handler(self, event):
        """
        Handle the join link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}")
                return
            
            account = self.tbot.handlers.get('join_account')
            
            # Join the group/channel
            await account.join_chat(link)
            account_name = account.session.filename if hasattr(account, 'session') and hasattr(account.session, 'filename') else 'Unknown'
            await event.respond(f"âœ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ {link} Ø¨Ø§ Ø­Ø³Ø§Ø¨ {account_name} Ø¹Ø¶Ùˆ Ø´Ø¯ÛŒØ¯.")
            
            # Cleanup
            self.tbot.handlers.pop('join_account', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error joining group/channel: {e}")
            await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¹Ø¶ÙˆÛŒØª Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„: {str(e)}")
            # Cleanup on error
            self.tbot.handlers.pop('join_account', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)

    async def left(self, account, event):
        """
        Perform the left action - leave a group or channel.
        """
        await event.respond("Ù„Ø·ÙØ§Ù‹ Ù„ÛŒÙ†Ú© ÛŒØ§ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ØªØ±Ú© Ú©Ø±Ø¯Ù† Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
        async with self.tbot._conversations_lock:
            self.tbot._conversations[event.chat_id] = 'left_link_handler'
        self.tbot.handlers['left_account'] = account

    async def left_link_handler(self, event):
        """
        Handle the leave link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}")
                return
            
            account = self.tbot.handlers.get('left_account')
            
            # Leave the group/channel
            entity = await account.get_entity(link)
            await account.leave_chat(entity)
            account_name = account.session.filename if hasattr(account, 'session') and hasattr(account.session, 'filename') else 'Unknown'
            await event.respond(f"âœ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø² {link} Ø¨Ø§ Ø­Ø³Ø§Ø¨ {account_name} Ø®Ø§Ø±Ø¬ Ø´Ø¯ÛŒØ¯.")
            
            # Cleanup
            self.tbot.handlers.pop('left_account', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error leaving group/channel: {e}")
            await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ±Ú© Ú©Ø±Ø¯Ù† Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„: {str(e)}")
            # Cleanup on error
            self.tbot.handlers.pop('left_account', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)

    async def block(self, account, event):
        """
        Perform the block action - block a user.
        """
        await event.respond("Ù„Ø·ÙØ§Ù‹ Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÙØ±Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù† Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
        async with self.tbot._conversations_lock:
            self.tbot._conversations[event.chat_id] = 'block_user_handler'
        self.tbot.handlers['block_account'] = account

    async def block_user_handler(self, event):
        """
        Handle the block user input.
        """
        try:
            user_input = event.message.text.strip()
            account = self.tbot.handlers.get('block_account')
            
            # Block the user
            from telethon.tl.functions.contacts import BlockRequest
            entity = await account.get_entity(user_input)
            await account(BlockRequest(entity))
            account_name = account.session.filename if hasattr(account, 'session') and hasattr(account.session, 'filename') else 'Unknown'
            await event.respond(f"âœ… Ú©Ø§Ø±Ø¨Ø± {user_input} Ø¨Ø§ Ø­Ø³Ø§Ø¨ {account_name} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù„Ø§Ú© Ø´Ø¯.")
            
            # Cleanup
            self.tbot.handlers.pop('block_account', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error blocking user: {e}")
            await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø±: {str(e)}")
            # Cleanup on error
            self.tbot.handlers.pop('block_account', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)

    async def send_pv(self, account, event):
        """
        Perform the send_pv action - send a private message to a user.
        """
        await event.respond("Ù„Ø·ÙØ§Ù‹ Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÙØ±Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
        async with self.tbot._conversations_lock:
            self.tbot._conversations[event.chat_id] = 'send_pv_user_handler'
        self.tbot.handlers['send_pv_account'] = account

    async def send_pv_user_handler(self, event):
        """
        Handle the send_pv user input.
        """
        try:
            user_input = event.message.text.strip()
            self.tbot.handlers['send_pv_user'] = user_input
            await event.respond("Ù„Ø·ÙØ§Ù‹ Ù…ØªÙ† Ù¾ÛŒØ§Ù… Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'send_pv_message_handler'
        except Exception as e:
            logger.error(f"Error in send_pv_user_handler: {e}")
            await event.respond("âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('send_pv_account', None)
            self.tbot.handlers.pop('send_pv_user', None)

    async def send_pv_message_handler(self, event):
        """
        Handle the send_pv message input.
        """
        try:
            message = event.message.text.strip()
            
            # Validate message text
            is_valid, error_msg = InputValidator.validate_message_text(message)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nÙ„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")
                return
            
            account = self.tbot.handlers.get('send_pv_account')
            user_input = self.tbot.handlers.get('send_pv_user')
            
            # Send the private message
            entity = await account.get_entity(user_input)
            await account.send_message(entity, message)
            account_name = account.session.filename if hasattr(account, 'session') and hasattr(account.session, 'filename') else 'Unknown'
            await event.respond(f"âœ… Ù¾ÛŒØ§Ù… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ {user_input} Ø¨Ø§ Ø­Ø³Ø§Ø¨ {account_name} Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.")
            
            # Cleanup
            self.tbot.handlers.pop('send_pv_account', None)
            self.tbot.handlers.pop('send_pv_user', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error sending private message: {e}")
            await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø®ØµÙˆØµÛŒ: {str(e)}")
            # Cleanup on error
            self.tbot.handlers.pop('send_pv_account', None)
            self.tbot.handlers.pop('send_pv_user', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)

    async def comment(self, account, event):
        """
        Perform the comment action - comment on a post/message.
        """
        await event.respond("Ù„Ø·ÙØ§Ù‹ Ù„ÛŒÙ†Ú© Ù¾Ø³Øª ÛŒØ§ Ù¾ÛŒØ§Ù… Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù…Ù†Øª Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
        async with self.tbot._conversations_lock:
            self.tbot._conversations[event.chat_id] = 'comment_link_handler'
        self.tbot.handlers['comment_account'] = account

    async def comment_link_handler(self, event):
        """
        Handle the comment link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nÙ„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")
                return
            
            self.tbot.handlers['comment_link'] = link
            await event.respond("Ù„Ø·ÙØ§Ù‹ Ù†Ø¸Ø± Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'comment_text_handler'
        except Exception as e:
            logger.error(f"Error in comment_link_handler: {e}")
            await event.respond("âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù„ÛŒÙ†Ú©. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('comment_account', None)
            self.tbot.handlers.pop('comment_link', None)

    async def comment_text_handler(self, event):
        """
        Handle the comment text input.
        """
        try:
            comment_text = event.message.text.strip()
            
            # Validate comment text
            is_valid, error_msg = InputValidator.validate_message_text(comment_text)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nÙ„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.")
                return
            
            account = self.tbot.handlers.get('comment_account')
            link = self.tbot.handlers.get('comment_link')
            is_bulk = self.tbot.handlers.get('comment_is_bulk', False)
            
            if is_bulk:
                # This is a bulk operation
                num_accounts = self.tbot.handlers.get('comment_num_accounts')

                # Get available accounts - DO NOT automatically remove unauthorized accounts during bulk operations
                # According to user requirements, accounts should only be removed if truly revoked by Telegram
                available_accounts = []
                unavailable_sessions = []

                async with self.tbot.active_clients_lock:
                    for session_name, client in list(self.tbot.active_clients.items())[:num_accounts]:
                        try:
                            # Check if client is connected and authorized
                            if not client.is_connected():
                                await client.connect()

                            if await client.is_user_authorized():
                                available_accounts.append((session_name, client))
                            else:
                                # Account is not authorized, but DO NOT remove it from active clients
                                # Just mark it as unavailable for this operation
                                unavailable_sessions.append(session_name)
                                logger.warning(f"Client {session_name} is currently not authorized (temporary issue), keeping in active list")
                        except Exception as e:
                            logger.error(f"Error validating client {session_name}: {e}")
                            unavailable_sessions.append(session_name)
                            # DO NOT remove from active clients due to temporary errors

                # If we have unavailable sessions, notify user but DON'T remove them
                if unavailable_sessions:
                    await event.respond(f"âš ï¸ {len(unavailable_sessions)} accounts are currently unavailable (temporary connectivity issues). Using remaining accounts.")

                # If no available accounts, stop
                if not available_accounts:
                    await event.respond("âŒ No accounts are currently available for this operation. Please check account status or try again later.")
                    return

                # Use available_accounts instead of valid_accounts
                valid_accounts = available_accounts

                # If no valid accounts, stop
                if not valid_accounts:
                    await event.respond("âŒ Ù‡ÛŒÚ† Ø­Ø³Ø§Ø¨ Ù…Ø¹ØªØ¨Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù…Ù†Øª ÛŒØ§ÙØª Ù†Ø´Ø¯.")
                    # Cleanup
                    self.tbot.handlers.pop('comment_num_accounts', None)
                    self.tbot.handlers.pop('comment_link', None)
                    self.tbot.handlers.pop('comment_is_bulk', None)
                    async with self.tbot._conversations_lock:
                        self.tbot._conversations.pop(event.chat_id, None)
                    return

                # Parse link once
                chat_entity, message_id = await self.parse_telegram_link(link, valid_accounts[0][1] if valid_accounts else None)

                if chat_entity is None or message_id is None:
                    raise ValueError(f"Failed to parse comment link: {link}")

                # Comment with all accounts
                success_count = 0
                error_count = 0
                
                async def comment_with_account(session_name, acc):
                    nonlocal success_count, error_count
                    async with self.operation_semaphore:
                        try:
                            # Resolve entity if needed
                            peer = chat_entity
                            if isinstance(peer, str):
                                peer = await acc.get_entity(peer)
                            elif isinstance(peer, int) and peer < 0:
                                peer = await acc.get_entity(peer)

                            await acc.send_message(peer, comment_text, reply_to=message_id)
                            success_count += 1
                            await asyncio.sleep(random.uniform(2, 5))
                        except Exception as e:
                            error_count += 1
                            error_msg = str(e)
                            logger.error(f"Error posting comment with account {session_name}: {error_msg}")

                            # If session is revoked, remove it from active clients
                            if "SessionRevokedError" in error_msg or "not logged in" in error_msg.lower():
                                async with self.tbot.active_clients_lock:
                                    if session_name in self.tbot.active_clients:
                                        logger.warning(f"Removing revoked session: {session_name}")
                                        del self.tbot.active_clients[session_name]

                # Use only valid accounts
                accounts_to_use = valid_accounts[:num_accounts]
                tasks = [comment_with_account(session_name, acc) for session_name, acc in accounts_to_use]
                await asyncio.gather(*tasks, return_exceptions=True)
                
                # Report results
                if error_count == 0:
                    await event.respond(f"âœ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù†Ø¸Ø± Ø¨Ø§ {success_count} Ø­Ø³Ø§Ø¨ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.")
                else:
                    await event.respond(f"âš ï¸ Ù†Ø¸Ø± Ø¨Ø§ {success_count} Ø­Ø³Ø§Ø¨ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯. {error_count} Ø­Ø³Ø§Ø¨ Ø¨Ø§ Ø®Ø·Ø§ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯.")
                
                # Cleanup
                self.tbot.handlers.pop('comment_link', None)
                self.tbot.handlers.pop('comment_num_accounts', None)
                self.tbot.handlers.pop('comment_is_bulk', None)
            else:
                # Individual operation
                chat_entity, message_id = await self.parse_telegram_link(link, account)
                
                if chat_entity is None or message_id is None:
                    raise ValueError(f"Failed to parse comment link: {link}")
                
                # Resolve entity if needed
                if isinstance(chat_entity, str):
                    chat_entity = await account.get_entity(chat_entity)
                
                # Send the comment
                await account.send_message(chat_entity, comment_text, reply_to=message_id)
                await event.respond(f"âœ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù†Ø¸Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.")
            
            # Cleanup
            self.tbot.handlers.pop('comment_account', None)
            self.tbot.handlers.pop('comment_link', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error posting comment: {e}")
            await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù†Ø¸Ø±: {str(e)}")
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            # Cleanup
            self.tbot.handlers.pop('comment_account', None)
            self.tbot.handlers.pop('comment_link', None)
            self.tbot.handlers.pop('comment_num_accounts', None)
            self.tbot.handlers.pop('comment_is_bulk', None)

    # ==================== Bulk Operation Handlers ====================
    
    async def bulk_poll(self, event, num_accounts):
        """
        Handle bulk poll operation - ask for link and option once, then vote with all accounts.
        """
        try:
            self.tbot.handlers['poll_num_accounts'] = num_accounts
            self.tbot.handlers['poll_is_bulk'] = True
            await event.respond("Ù„Ø·ÙØ§Ù‹ Ù„ÛŒÙ†Ú© Ù†Ø¸Ø±Ø³Ù†Ø¬ÛŒ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'poll_link_handler'
        except Exception as e:
            logger.error(f"Error in bulk_poll: {e}")
            await event.respond("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¹Ù…Ù„ÛŒØ§Øª bulk poll.")
            self.tbot.handlers.pop('poll_num_accounts', None)
            self.tbot.handlers.pop('poll_is_bulk', None)
    
    async def bulk_join(self, event, num_accounts):
        """
        Handle bulk join operation - ask for link once, then join with all accounts.
        """
        try:
            await event.respond("Ù„Ø·ÙØ§Ù‹ Ù„ÛŒÙ†Ú© Ú¯Ø±ÙˆÙ‡ ÛŒØ§ Ú©Ø§Ù†Ø§Ù„ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø¹Ø¶ÙˆÛŒØª Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'bulk_join_link_handler'
            self.tbot.handlers['join_num_accounts'] = num_accounts
        except Exception as e:
            logger.error(f"Error in bulk_join: {e}")
            await event.respond("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¹Ù…Ù„ÛŒØ§Øª bulk join.")
            self.tbot.handlers.pop('join_num_accounts', None)
    
    async def bulk_join_link_handler(self, event):
        """
        Handle bulk join link input.
        """
        try:
            link = event.message.text.strip()
            
            # Validate link
            is_valid, error_msg = InputValidator.validate_telegram_link(link)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}")
                async with self.tbot._conversations_lock:
                    self.tbot._conversations.pop(event.chat_id, None)
                self.tbot.handlers.pop('join_num_accounts', None)
                return
            
            num_accounts = self.tbot.handlers.get('join_num_accounts')

            # Get available accounts using helper function
            available_accounts, unavailable_sessions = await self.get_available_accounts(num_accounts)
            
            # Don't show annoying message - just use available accounts silently
            if unavailable_sessions:
                logger.info(f"{len(unavailable_sessions)} accounts temporarily unavailable, using {len(available_accounts)} available accounts")

            # If no available accounts, stop
            if not available_accounts:
                await event.respond("âŒ No accounts are currently available for this operation. Please check account status or try again later.")
                return

            # Use available_accounts instead of valid_accounts
            valid_accounts = available_accounts

            # If no valid accounts, stop
            if not valid_accounts:
                await event.respond("âŒ Ù‡ÛŒÚ† Ø­Ø³Ø§Ø¨ Ù…Ø¹ØªØ¨Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø¹Ø¶ÙˆÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯.")
                # Cleanup
                self.tbot.handlers.pop('join_num_accounts', None)
                async with self.tbot._conversations_lock:
                    self.tbot._conversations.pop(event.chat_id, None)
                return

            success_count = 0
            error_count = 0

            async def join_with_account(session_name, acc):
                nonlocal success_count, error_count
                async with self.operation_semaphore:
                    try:
                        await acc.join_chat(link)
                        success_count += 1
                        await asyncio.sleep(random.uniform(2, 5))
                    except Exception as e:
                        error_count += 1
                        error_msg = str(e)
                        logger.error(f"Error joining with account {session_name}: {error_msg}")

                        # If session is revoked, remove it from active clients
                        if "SessionRevokedError" in error_msg or "not logged in" in error_msg.lower():
                            async with self.tbot.active_clients_lock:
                                if session_name in self.tbot.active_clients:
                                    logger.warning(f"Removing revoked session: {session_name}")
                                    del self.tbot.active_clients[session_name]
            
            # Use only valid accounts
            accounts_to_use = valid_accounts[:num_accounts]
            tasks = [join_with_account(session_name, acc) for session_name, acc in accounts_to_use]
            await asyncio.gather(*tasks, return_exceptions=True)
            
            # Report results
            if error_count == 0:
                await event.respond(f"âœ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§ {success_count} Ø­Ø³Ø§Ø¨ Ø¹Ø¶Ùˆ Ø´Ø¯ÛŒØ¯.")
            else:
                await event.respond(f"âš ï¸ Ø¨Ø§ {success_count} Ø­Ø³Ø§Ø¨ Ø¹Ø¶Ùˆ Ø´Ø¯ÛŒØ¯. {error_count} Ø­Ø³Ø§Ø¨ Ø¨Ø§ Ø®Ø·Ø§ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯.")
            
            # Cleanup
            self.tbot.handlers.pop('join_num_accounts', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error in bulk_join_link_handler: {e}")
            await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¹Ø¶ÙˆÛŒØª Ú¯Ø±ÙˆÙ‡/Ú©Ø§Ù†Ø§Ù„: {str(e)}")
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('join_num_accounts', None)
    
    async def bulk_block(self, event, num_accounts):
        """
        Handle bulk block operation - ask for user once, then block with all accounts.
        """
        try:
            await event.respond("Ù„Ø·ÙØ§Ù‹ Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÙØ±Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù† Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'bulk_block_user_handler'
            self.tbot.handlers['block_num_accounts'] = num_accounts
        except Exception as e:
            logger.error(f"Error in bulk_block: {e}")
            await event.respond("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¹Ù…Ù„ÛŒØ§Øª bulk block.")
            self.tbot.handlers.pop('block_num_accounts', None)
    
    async def bulk_block_user_handler(self, event):
        """
        Handle bulk block user input.
        """
        try:
            user_input = event.message.text.strip()
            
            num_accounts = self.tbot.handlers.get('block_num_accounts')

            # Get available accounts using helper function
            available_accounts, unavailable_sessions = await self.get_available_accounts(num_accounts)
            
            # Don't show annoying message - just use available accounts silently
            if unavailable_sessions:
                logger.info(f"{len(unavailable_sessions)} accounts temporarily unavailable, using {len(available_accounts)} available accounts")

            # If no available accounts, stop
            if not available_accounts:
                await event.respond("âŒ No accounts are currently available for this operation. Please check account status or try again later.")
                return

            # Use available_accounts instead of valid_accounts
            valid_accounts = available_accounts

            # If no valid accounts, stop
            if not valid_accounts:
                await event.respond("âŒ Ù‡ÛŒÚ† Ø­Ø³Ø§Ø¨ Ù…Ø¹ØªØ¨Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù† ÛŒØ§ÙØª Ù†Ø´Ø¯.")
                # Cleanup
                self.tbot.handlers.pop('block_num_accounts', None)
                async with self.tbot._conversations_lock:
                    self.tbot._conversations.pop(event.chat_id, None)
                return

            success_count = 0
            error_count = 0

            async def block_with_account(session_name, acc):
                nonlocal success_count, error_count
                async with self.operation_semaphore:
                    try:
                        from telethon.tl.functions.contacts import BlockRequest
                        entity = await acc.get_entity(user_input)
                        await acc(BlockRequest(entity))
                        success_count += 1
                        await asyncio.sleep(random.uniform(2, 5))
                    except Exception as e:
                        error_count += 1
                        error_msg = str(e)
                        logger.error(f"Error blocking user with account {session_name}: {error_msg}")

                        # If session is revoked, remove it from active clients
                        if "SessionRevokedError" in error_msg or "not logged in" in error_msg.lower():
                            async with self.tbot.active_clients_lock:
                                if session_name in self.tbot.active_clients:
                                    logger.warning(f"Removing revoked session: {session_name}")
                                    del self.tbot.active_clients[session_name]
            
            # Use only valid accounts
            accounts_to_use = valid_accounts[:num_accounts]
            tasks = [block_with_account(session_name, acc) for session_name, acc in accounts_to_use]
            await asyncio.gather(*tasks, return_exceptions=True)
            
            # Report results
            if error_count == 0:
                await event.respond(f"âœ… Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ú©Ø§Ø±Ø¨Ø± {user_input} Ø¨Ø§ {success_count} Ø­Ø³Ø§Ø¨ Ø¨Ù„Ø§Ú© Ø´Ø¯.")
            else:
                await event.respond(f"âš ï¸ Ú©Ø§Ø±Ø¨Ø± {user_input} Ø¨Ø§ {success_count} Ø­Ø³Ø§Ø¨ Ø¨Ù„Ø§Ú© Ø´Ø¯. {error_count} Ø­Ø³Ø§Ø¨ Ø¨Ø§ Ø®Ø·Ø§ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯.")
            
            # Cleanup
            self.tbot.handlers.pop('block_num_accounts', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            
        except Exception as e:
            logger.error(f"Error in bulk_block_user_handler: {e}")
            await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù„Ø§Ú© Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø±: {str(e)}")
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('block_num_accounts', None)
    
    async def bulk_send_pv_account_count_handler(self, event):
        """
        Handle bulk send_pv account count input.
        """
        logger.info("bulk_send_pv_account_count_handler called")
        try:
            user_input = event.message.text.strip()
            logger.info(f"User input for account count: '{user_input}'")

            # Get total available accounts
            async with self.tbot.active_clients_lock:
                total_accounts = len(self.tbot.active_clients)
            logger.info(f"Total available accounts: {total_accounts}")

            # Validate input is a number
            if not user_input.isdigit():
                logger.warning(f"Invalid input: '{user_input}' is not a digit")
                await event.respond(f"âŒ Please enter a valid number between 1 and {total_accounts}.")
                return

            num_accounts = int(user_input)
            logger.info(f"Parsed number: {num_accounts}")

            # Validate range
            if num_accounts < 1 or num_accounts > total_accounts:
                logger.warning(f"Number {num_accounts} is out of range 1-{total_accounts}")
                await event.respond(f"âŒ Please enter a number between 1 and {total_accounts}.")
                return

            # Store the number and proceed to ask for username
            logger.info("Proceeding to ask for username")
            await event.respond("Please provide the user ID or username to send a message to:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'bulk_send_pv_user_handler'
            self.tbot.handlers['send_pv_num_accounts'] = num_accounts
            logger.info("Conversation state updated and handlers set")

        except Exception as e:
            logger.error(f"Error in bulk_send_pv_account_count_handler: {e}")
            await event.respond("âŒ An error occurred. Please try again.")
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)

    async def bulk_send_pv(self, event, num_accounts):
        """
        Handle bulk send_pv operation - ask for user and message once, then send with all accounts.
        """
        try:
            await event.respond("Please provide the user ID or username to send a message to:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'bulk_send_pv_user_handler'
            self.tbot.handlers['send_pv_num_accounts'] = num_accounts
        except Exception as e:
            logger.error(f"Error in bulk_send_pv: {e}")
            await event.respond("âŒ Error starting bulk send_pv operation.")
            self.tbot.handlers.pop('send_pv_num_accounts', None)
    
    async def bulk_send_pv_user_handler(self, event):
        """
        Handle bulk send_pv user input.
        """
        try:
            user_input = event.message.text.strip()
            self.tbot.handlers['send_pv_user'] = user_input
            await event.respond("Please send the message you want to send:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'bulk_send_pv_message_handler'
        except Exception as e:
            logger.error(f"Error in bulk_send_pv_user_handler: {e}")
            await event.respond("âŒ Error processing user information. Please try again.")
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('send_pv_num_accounts', None)
            self.tbot.handlers.pop('send_pv_user', None)

    def _is_config_message(self, message):
        """
        Check if a message looks like a configuration/command message rather than actual content.
        """
        if not message:
            return True

        # Check if it's just a number (account count)
        if message.isdigit():
            return True

        # Check if it's just usernames (contains @)
        words = message.split()
        username_count = 0
        for word in words:
            if word.startswith('@'):
                username_count += 1
            elif not word.replace(' ', '').isalnum():
                # If it contains non-alphanumeric characters (except spaces), it's probably content
                break
        else:
            # If all words are either usernames or simple alphanumeric, check if it's mostly usernames
            if username_count > 0 and username_count >= len(words) * 0.7:  # 70% or more are usernames
                return len(words) <= 10  # Reasonable limit for username list

        # Check for very short messages that might be commands
        if len(message) < 3:
            return True

        # Check for messages that look like bot commands
        if message.startswith('/') or message.startswith('!') or message.startswith('.'):
            return True

        # If message is longer than 15 characters and contains normal text, it's definitely content
        if len(message) > 15 and any(char.isalpha() for char in message):
            return False

        # Messages between 3-15 characters are ambiguous, check for meaningful content
        if 3 <= len(message) <= 15:
            # If it has punctuation or multiple words, it's probably content
            if any(char in message for char in '.,!?;:') or ' ' in message:
                return False
            # Single words that are not obvious commands
            if len(message.split()) == 1 and not message.isupper():
                return False

        return False

    async def bulk_send_pv_message_handler(self, event):
        """
        Handle bulk send_pv message with SMART SYSTEM:
        - Ù…Ø­Ø¯ÙˆØ¯ÛŒØª 4 Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø§Ú©Ø§Ù†Øª
        - Ø§Ù†ØªØ®Ø§Ø¨ Ø±Ù†Ø¯ÙˆÙ… Ø§Ú©Ø§Ù†Øªâ€ŒÙ‡Ø§
        - ØªØ§ÛŒÛŒØ¯ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…
        - Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§
        - Ú†Ø±Ø®Ù‡ Ù…Ø¬Ø¯Ø¯
        """
        try:
            message = event.message.text.strip()

            # Check if this message is actually a command/configuration message, not the final message
            if self._is_config_message(message):
                logger.info(f"Ignoring config-like message: '{message}'")
                await event.respond("âŒ Please send the actual message you want to send to users.")
                return

            # Validate message text
            is_valid, error_msg = InputValidator.validate_message_text(message)
            if not is_valid:
                await event.respond(f"âŒ {error_msg}\nPlease try again.")
                return

            user_input = self.tbot.handlers.get('send_pv_user')
            num_accounts = self.tbot.handlers.get('send_pv_num_accounts')

            # Check if we have the required configuration
            if not user_input or not num_accounts:
                await event.respond("âŒ Configuration incomplete. Please start over with Bulk -> Send PV.")
                # Cleanup
                self.tbot.handlers.pop('send_pv_num_accounts', None)
                self.tbot.handlers.pop('send_pv_user', None)
                async with self.tbot._conversations_lock:
                    self.tbot._conversations.pop(event.chat_id, None)
                return

            # Get available accounts using helper function
            available_accounts, unavailable_sessions = await self.get_available_accounts(num_accounts)
            
            # Log unavailable sessions
            if unavailable_sessions:
                logger.info(f"{len(unavailable_sessions)} accounts temporarily unavailable, using {len(available_accounts)} available accounts")

            # If no available accounts, stop
            if not available_accounts:
                await event.respond("âŒ No accounts are currently available for sending messages. Please check account status or try again later.")
                # Cleanup
                self.tbot.handlers.pop('send_pv_num_accounts', None)
                self.tbot.handlers.pop('send_pv_user', None)
                async with self.tbot._conversations_lock:
                    self.tbot._conversations.pop(event.chat_id, None)
                return

            # Parse user list from input
            user_list = []
            for user in user_input.split():
                user = user.strip()
                if user.startswith('@'):
                    user_list.append(user[1:])  # Remove @ prefix
                else:
                    user_list.append(user)

            logger.info(f"Parsed {len(user_list)} users: {user_list}")

            if not user_list:
                await event.respond("âŒ No valid usernames provided.")
                # Cleanup
                self.tbot.handlers.pop('send_pv_num_accounts', None)
                self.tbot.handlers.pop('send_pv_user', None)
                async with self.tbot._conversations_lock:
                    self.tbot._conversations.pop(event.chat_id, None)
                return

            # ========== Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø³ÛŒØ³ØªÙ… Ø¬Ø¯ÛŒØ¯ SmartBulkSender ==========
            
            await event.respond(f"ğŸš€ Starting smart bulk send...\nğŸ“Š {len(user_list)} usernames, {len(available_accounts)} accounts\nğŸ’¡ Each account will send max 4 messages")
            
            # Ø§ÛŒØ¬Ø§Ø¯ sender Ø¨Ø§ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª 4 Ù¾ÛŒØ§Ù…
            sender = SmartBulkSender(
                accounts=available_accounts,
                usernames=user_list,
                message=message,
                max_per_account=4  # Ù…Ø­Ø¯ÙˆØ¯ÛŒØª 4 Ù¾ÛŒØ§Ù…
            )
            
            # Progress tracking
            last_progress_message = None
            
            async def progress_callback(status_text):
                nonlocal last_progress_message
                try:
                    if last_progress_message:
                        try:
                            await last_progress_message.delete()
                        except:
                            pass
                    last_progress_message = await event.respond(status_text)
                except:
                    pass
            
            # Ø§Ø¬Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„
            results = await sender.send_all(progress_callback=progress_callback)
            
            # Ø¢Ù…Ø§Ø± Ù†Ù‡Ø§ÛŒÛŒ
            success_count = results["total_sent"]
            error_count = results["total_failed"]
            total_users = len(user_list)
            
            # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù¾ÛŒØ§Ù… progress
            try:
                if last_progress_message:
                    await last_progress_message.delete()
            except:
                pass
            
            # Ú¯Ø²Ø§Ø±Ø´ Ù†Ù‡Ø§ÛŒÛŒ
            result_message = ""
            if error_count == 0:
                result_message = f"âœ… Message successfully sent to ALL {success_count} users!\n\n"
            else:
                result_message = f"âš ï¸ Message sent to {success_count} users, {error_count} failed. Total: {total_users}\n\n"
            
            # Ø¢Ù…Ø§Ø± Ø§Ú©Ø§Ù†Øªâ€ŒÙ‡Ø§
            result_message += "ğŸ“Š Account Performance:\n"
            for session, stats in results["account_stats"].items():
                phone = session.replace('.session', '').replace('+', '')
                result_message += f"  â€¢ {phone}: âœ… {stats['success']} | âŒ {stats['failed']}\n"
            
            # Ø§Ú¯Ø± usernameâ€ŒÙ‡Ø§ÛŒÛŒ Ú©Ø§Ù…Ù„Ø§Ù‹ fail Ø´Ø¯Ù†Ø¯
            if results["failed_usernames"]:
                result_message += f"\nâŒ Could not send to: {', '.join(results['failed_usernames'][:5])}"
                if len(results["failed_usernames"]) > 5:
                    result_message += f" and {len(results['failed_usernames'])-5} more"
            
            await event.respond(result_message)
            
            # Cleanup
            self.tbot.handlers.pop('send_pv_num_accounts', None)
            self.tbot.handlers.pop('send_pv_user', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)

        except Exception as e:
            logger.error(f"Error in bulk_send_pv_message_handler: {e}", exc_info=True)
            await event.respond("âŒ An error occurred during message sending.")
            # Cleanup
            self.tbot.handlers.pop('send_pv_num_accounts', None)
            self.tbot.handlers.pop('send_pv_user', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
    
    async def bulk_comment(self, event, num_accounts):
                    
                    # Verify account is working
                    try:
                        me = await account.get_me()
                        if not me:
                            logger.error(f"Account {session_name} get_me() returned None")
                            return False
                    except Exception as auth_error:
                        logger.error(f"Account {session_name} is not authorized: {auth_error}")
                        return False
                    
                    # Try multiple methods to send - START WITH DIRECT SEND (most reliable)
                    # Don't try to resolve entity first - it can cause NoneType errors
                    send_methods = [
                        (f"@{clean_user}", "direct with @"),
                        (clean_user, "direct without @"),
                    ]
                    
                    # Try to resolve entity as a fallback (but don't fail if it doesn't work)
                    entity = None
                    try:
                        # Try with @ first
                        try:
                            entity = await account.get_entity(f"@{clean_user}")
                            if entity:
                                send_methods.insert(0, (entity, "resolved entity with @"))
                                logger.info(f"âœ… Resolved entity for @{clean_user} with {session_name}")
                        except:
                            pass
                        
                        # Try without @
                        if not entity:
                            try:
                                entity = await account.get_entity(clean_user)
                                if entity:
                                    send_methods.insert(0, (entity, "resolved entity without @"))
                                    logger.info(f"âœ… Resolved entity for {clean_user} with {session_name}")
                            except:
                                pass
                    except Exception as resolve_error:
                        # Entity resolution failed - that's OK, we'll use direct methods
                        logger.debug(f"Entity resolution failed for {clean_user}: {resolve_error}")
                    
                    last_error = None
                    for method_target, method_name in send_methods:
                        try:
                            # Check if method_target is None (shouldn't happen, but safety check)
                            if method_target is None:
                                logger.warning(f"Method target is None for {method_name}, skipping")
                                continue
                            
                            # Send message
                            await account.send_message(method_target, message_text)
                            logger.info(f"âœ… Successfully sent to {clean_user} via {method_name} with {session_name}")
                            return True
                                
                        except Exception as send_error:
                            error_str = str(send_error).lower()
                            error_msg = error_str
                            last_error = send_error
                            
                            # Handle NoneType errors specifically
                            if 'nonetype' in error_msg or 'cannot cast' in error_msg or 'peer' in error_msg:
                                logger.warning(f"NoneType/Peer error for {clean_user} with {session_name} via {method_name}: {send_error}")
                                # Try next method
                                continue
                            
                            # Rate limiting - should retry with different account
                            if any(kw in error_msg for kw in ['too many requests', 'flood', 'rate limit', 'floodwait']):
                                logger.warning(f"Rate limit for {clean_user} with {session_name} - will retry")
                                return "RATE_LIMIT"
                            
                            # Username not found - only fail if this is the last method
                            if any(kw in error_msg for kw in ['username', 'not found', 'invalid', 'no user', 'user not found', 'could not find', 'no entity']):
                                if method_name == "direct without @":  # Last method
                                    logger.warning(f"Username {clean_user} not found or invalid with {session_name}")
                                    return False
                                continue  # Try next method
                            
                            # Privacy/blocked - might work with different account or method
                            if any(kw in error_msg for kw in ['privacy', 'blocked', 'restricted', 'cannot send', 'user is blocking', 'user privacy']):
                                logger.warning(f"Cannot send to {clean_user}: privacy/blocked with {session_name} via {method_name}")
                                # Don't return False - might work with different account
                                continue
                            
                            # Other errors - try next method
                            logger.debug(f"Method {method_name} failed for {clean_user}: {send_error}")
                            continue
                    
                    # All methods failed
                    if last_error:
                        logger.warning(f"All methods failed for {clean_user} with {session_name}. Last error: {last_error}")
                    else:
                        logger.warning(f"All methods failed for {clean_user} with {session_name}")
                    return False
                        
                except Exception as e:
                    error_msg = str(e).lower()
                    logger.error(f"Error sending private message with account {session_name} to {original_user}: {error_msg}")

                    if "sessionrevokederror" in error_msg or "not logged in" in error_msg:
                        async with self.tbot.active_clients_lock:
                            if session_name in self.tbot.active_clients:
                                logger.warning(f"Removing revoked session: {session_name}")
                                del self.tbot.active_clients[session_name]

                    return False

            # Execute all tasks with concurrency control but limit concurrent operations
            semaphore = asyncio.Semaphore(3)  # Limit to 3 concurrent operations for better stability

            async def send_with_semaphore(session_name, account, target_user, message_text):
                async with semaphore:
                    # Add delay to avoid rate limiting (increased delay)
                    await asyncio.sleep(random.uniform(2, 4))
                    return await send_pv_with_account(session_name, account, target_user, message_text)

            # Create tasks for all assignments
            tasks = []
            for session_name, account, target_user in account_assignments:
                task = send_with_semaphore(session_name, account, target_user, message)
                tasks.append(task)

            # Execute all tasks
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Track which accounts failed and which users failed
            failed_accounts = set()
            failed_users = []

            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    error_count += 1
                    logger.error(f"Task {i} failed with exception: {result}")
                    session_name, account, target_user = account_assignments[i]
                    failed_accounts.add(session_name)
                    failed_users.append((target_user, i))
                elif result == True:
                    success_count += 1
                elif result == "RATE_LIMIT":
                    # Rate limited - will retry
                    error_count += 1
                    session_name, account, target_user = account_assignments[i]
                    failed_accounts.add(session_name)
                    failed_users.append((target_user, i))
                else:
                    # False or None - failed
                    error_count += 1
                    session_name, account, target_user = account_assignments[i]
                    failed_accounts.add(session_name)
                    failed_users.append((target_user, i))
            
            # Retry failed messages with ALL available accounts - ULTIMATE RETRY with multiple rounds
            if failed_users and len(valid_accounts) > 0:
                logger.info(f"ğŸ”„ Retrying {len(failed_users)} failed messages with ALL {len(valid_accounts)} available accounts...")
                retry_success = 0
                rate_limited_users = []
                still_failed_users = []
                
                # ROUND 1: Try with all accounts (except original if it wasn't rate limited)
                for target_user, original_index in failed_users:
                    original_session = account_assignments[original_index][0]
                    retried = False
                    
                    # Try with ALL accounts in order
                    for attempt_num, (session_name, account) in enumerate(valid_accounts, 1):
                        # Only skip original account if it wasn't rate limited
                        if session_name == original_session and results[original_index] != "RATE_LIMIT":
                            logger.debug(f"Skipping original account {session_name} for {target_user} (already tried)")
                            continue
                        
                        try:
                            logger.info(f"ğŸ”„ Round 1 - Retry attempt {attempt_num}/{len(valid_accounts)}: {target_user} with account {session_name}...")
                            
                            # Ensure account is connected before retry
                            if not account.is_connected():
                                try:
                                    await account.connect()
                                    await asyncio.sleep(1)  # Wait after connection
                                except Exception as conn_err:
                                    logger.warning(f"Could not connect {session_name} for retry: {conn_err}")
                                    continue
                            
                            # Add delay before retry
                            await asyncio.sleep(random.uniform(2, 4))
                            
                            result = await send_pv_with_account(session_name, account, target_user, message)
                            
                            if result == True:
                                # Success!
                                results[original_index] = True
                                success_count += 1
                                error_count -= 1
                                retry_success += 1
                                logger.info(f"âœ… SUCCESS! Retried {target_user} with {session_name}")
                                retried = True
                                await asyncio.sleep(random.uniform(2, 3))
                                break
                            elif result == "RATE_LIMIT":
                                # Rate limited - try next account
                                logger.warning(f"âš ï¸ Rate limited for {target_user} with {session_name}, trying next account...")
                                rate_limited_users.append((target_user, original_index))
                                await asyncio.sleep(random.uniform(3, 5))
                                continue
                            else:
                                # Failed - try next account
                                logger.debug(f"âŒ Failed to send to {target_user} with {session_name}, trying next account...")
                                await asyncio.sleep(random.uniform(2, 3))
                                continue
                                
                        except Exception as retry_error:
                            error_str = str(retry_error).lower()
                            logger.error(f"âŒ Retry exception for {target_user} with {session_name}: {retry_error}")
                            
                            # If it's a connection/auth error, skip this account
                            if any(kw in error_str for kw in ['not connected', 'not authorized', 'session', 'auth']):
                                logger.warning(f"Skipping {session_name} due to auth/connection issue")
                                continue
                            
                            await asyncio.sleep(random.uniform(2, 3))
                            continue
                    
                    if not retried:
                        still_failed_users.append((target_user, original_index))
                        logger.warning(f"âš ï¸ Could not send to {target_user} with ANY account in Round 1")
                
                # ROUND 2: Try again with ALL accounts including original (with longer delays)
                if still_failed_users and len(valid_accounts) > 0:
                    logger.info(f"ğŸ”„ Round 2: Retrying {len(still_failed_users)} still-failed messages with ALL accounts (including original)...")
                    await asyncio.sleep(5)  # Wait before round 2
                    
                    for target_user, original_index in still_failed_users:
                        if results[original_index] == True:
                            continue  # Already succeeded
                        
                        retried = False
                        for attempt_num, (session_name, account) in enumerate(valid_accounts, 1):
                            try:
                                logger.info(f"ğŸ”„ Round 2 - Attempt {attempt_num}/{len(valid_accounts)}: {target_user} with account {session_name}...")
                                
                                if not account.is_connected():
                                    try:
                                        await account.connect()
                                        await asyncio.sleep(2)
                                    except Exception as conn_err:
                                        logger.warning(f"Could not connect {session_name} for round 2: {conn_err}")
                                        continue
                                
                                # Longer delay in round 2
                                await asyncio.sleep(random.uniform(4, 6))
                                
                                result = await send_pv_with_account(session_name, account, target_user, message)
                                
                                if result == True:
                                    results[original_index] = True
                                    success_count += 1
                                    error_count -= 1
                                    retry_success += 1
                                    logger.info(f"âœ… SUCCESS in Round 2! {target_user} with {session_name}")
                                    retried = True
                                    await asyncio.sleep(random.uniform(3, 4))
                                    break
                                elif result == "RATE_LIMIT":
                                    rate_limited_users.append((target_user, original_index))
                                    await asyncio.sleep(random.uniform(5, 7))
                                    continue
                                else:
                                    await asyncio.sleep(random.uniform(3, 5))
                                    continue
                                    
                            except Exception as round2_error:
                                logger.debug(f"Round 2 error for {target_user} with {session_name}: {round2_error}")
                                await asyncio.sleep(random.uniform(3, 5))
                                continue
                        
                        if not retried:
                            logger.warning(f"âš ï¸ Still failed: {target_user} after Round 2")
                
                # ROUND 3: Handle rate limited users with longer wait
                if rate_limited_users and len(valid_accounts) > 0:
                    logger.info(f"â³ Waiting 20 seconds before retrying {len(rate_limited_users)} rate-limited users...")
                    await asyncio.sleep(20)  # Wait longer for rate limit to reset
                    
                    for target_user, original_index in rate_limited_users:
                        if results[original_index] == True:
                            continue  # Already succeeded
                        
                        logger.info(f"ğŸ”„ Round 3 - Final retry for rate-limited user: {target_user}")
                        # Try with ALL accounts again
                        for session_name, account in valid_accounts:
                            try:
                                if not account.is_connected():
                                    await account.connect()
                                    await asyncio.sleep(2)
                                
                                await asyncio.sleep(random.uniform(5, 7))
                                
                                result = await send_pv_with_account(session_name, account, target_user, message)
                                if result == True:
                                    results[original_index] = True
                                    success_count += 1
                                    error_count -= 1
                                    retry_success += 1
                                    logger.info(f"âœ… Successfully sent to rate-limited {target_user} with {session_name} in Round 3")
                                    await asyncio.sleep(random.uniform(3, 4))
                                    break
                            except Exception as final_error:
                                logger.debug(f"Final retry failed for {target_user} with {session_name}: {final_error}")
                                await asyncio.sleep(random.uniform(3, 5))
                                continue
            
            # Check report status for ALL accounts used in this task (not just failed ones)
            reported_accounts = []
            accounts_to_check = set()
            
            # Add all accounts that were used
            for session_name, _, _ in account_assignments:
                accounts_to_check.add(session_name)
            
            # Also add failed accounts
            accounts_to_check.update(failed_accounts)
            
            if accounts_to_check and REPORT_CHECK_BOT:
                logger.info(f"Checking report status for {len(accounts_to_check)} accounts...")
                await event.respond(f"ğŸ” Checking report status for {len(accounts_to_check)} accounts...")
                
                for session_name in accounts_to_check:
                    try:
                        # Get phone number from session name
                        # Session name format: +1234567890 or +1234567890.session
                        phone_number = session_name.replace('.session', '').strip()
                        if not phone_number.startswith('+'):
                            # If it doesn't start with +, try to add it
                            phone_number = '+' + phone_number
                        
                        # Get account client
                        account = None
                        async with self.tbot.active_clients_lock:
                            if session_name in self.tbot.active_clients:
                                account = self.tbot.active_clients[session_name]
                        
                        if account:
                            # Check report status
                            is_reported = await self.check_report_status(phone_number, account)
                            if is_reported:
                                reported_accounts.append(session_name)
                                # Save report status to config
                                if 'clients' in self.tbot.config:
                                    if session_name in self.tbot.config['clients']:
                                        if not isinstance(self.tbot.config['clients'][session_name], dict):
                                            # Convert to dict format
                                            old_groups = self.tbot.config['clients'][session_name]
                                            self.tbot.config['clients'][session_name] = {
                                                'groups': old_groups if isinstance(old_groups, list) else [],
                                                'is_reported': True
                                            }
                                        else:
                                            self.tbot.config['clients'][session_name]['is_reported'] = True
                                        
                                        # Save config
                                        self.tbot.config_manager.save_config(self.tbot.config)
                                        logger.info(f"Marked {session_name} as reported in config")
                    except Exception as e:
                        logger.error(f"Error checking report status for {session_name}: {e}")
            elif not REPORT_CHECK_BOT:
                logger.warning("REPORT_CHECK_BOT not configured. Skipping report check.")

            # Report results
            total_users = len(user_list)
            result_message = ""
            if error_count == 0:
                result_message = f"âœ… Message successfully sent to all {success_count} users using account rotation."
            else:
                result_message = f"âš ï¸ Message sent to {success_count} users, {error_count} failed. Total users: {total_users}"
            
            # Add report status if any accounts are reported
            if reported_accounts:
                reported_phones = [acc.replace('.session', '') for acc in reported_accounts]
                result_message += f"\n\nâš ï¸ Reported accounts detected: {', '.join(reported_phones)}"
            
            await event.respond(result_message)

            # Show account usage summary
            account_usage = {}
            for session_name, _, _ in account_assignments:
                account_usage[session_name] = account_usage.get(session_name, 0) + 1

            usage_summary = "ğŸ“Š Account Usage Summary:\n"
            for account_name, count in account_usage.items():
                usage_summary += f"â€¢ {account_name}: {count} messages sent\n"

            await event.respond(usage_summary)

            # Cleanup
            self.tbot.handlers.pop('send_pv_num_accounts', None)
            self.tbot.handlers.pop('send_pv_user', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)

        except Exception as e:
            logger.error(f"Error in bulk_send_pv_message_handler: {e}")
            await event.respond("âŒ An error occurred during message sending.")
            # Cleanup
            self.tbot.handlers.pop('send_pv_num_accounts', None)
            self.tbot.handlers.pop('send_pv_user', None)
            async with self.tbot._conversations_lock:
                self.tbot._conversations.pop(event.chat_id, None)
            self.tbot.handlers.pop('send_pv_num_accounts', None)
            self.tbot.handlers.pop('send_pv_user', None)
    
    async def bulk_comment(self, event, num_accounts):
        """
        Handle bulk comment operation - ask for link and text once, then comment with all accounts.
        """
        try:
            self.tbot.handlers['comment_num_accounts'] = num_accounts
            self.tbot.handlers['comment_is_bulk'] = True
            await event.respond("Ù„Ø·ÙØ§Ù‹ Ù„ÛŒÙ†Ú© Ù¾Ø³Øª ÛŒØ§ Ù¾ÛŒØ§Ù… Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù…Ù†Øª Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
            async with self.tbot._conversations_lock:
                self.tbot._conversations[event.chat_id] = 'comment_link_handler'
        except Exception as e:
            logger.error(f"Error in bulk_comment: {e}")
            await event.respond("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¹Ù…Ù„ÛŒØ§Øª bulk comment.")
            self.tbot.handlers.pop('comment_num_accounts', None)
            self.tbot.handlers.pop('comment_is_bulk', None)

